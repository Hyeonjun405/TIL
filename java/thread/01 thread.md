## 1. 자바에서 쓰레드
### 1. Runnable 인터페이스
  ```
  class MyTask implements Runnable {
    // run() 메서드만 하나 가짐
    @Override
    public void run() { 
        System.out.println("Runnable로 실행됨");
     }
   }

   public class Main {
    public static void main(String[] args) {
        Runnable task = new MyTask();
        //Thread 클래스에 작업을 넘겨줘서 위임 방식으로 실행함.
        Thread thread = new Thread(task);
        thread.start();  // 쓰레드 시작
      }
  }
  ```


### 2. Thread 클래스
  ```
   class MyThread extends Thread {
      @Override
      public void run() {
          System.out.println("Thread로 실행됨");
      }
   }

   public class Main {
      public static void main(String[] args) {
          Thread thread = new MyThread();
          thread.start();  // 쓰레드 시작
      }
   }
  ```

### 3. Check 🔍
- Thread 클래스의 start() 메서드를 호출하면, JVM이 새로운 OS 쓰레드를 생성하고 내부적으로 run() 메서드를 호출하여 멀티스레드로 작업을 수행함.
- Thread 클래스를 직접 상속받는 방식은 이미 상속을 사용하고 있는 클래스와는 동시에 사용할 수 없기 때문에 제한적
- 따라서 Runnable 인터페이스를 구현하면 클래스의 상속이 자유롭고, 더 유연하게 쓰레드를 구성할 수 있음.

## 2. 쓰레드 메소드
### 1. 생성 / 실행

| 메서드            | 설명                 |
| ------ | ----------------------------- |
| `run()`                           | 쓰레드가 수행할 코드를 정의하는 곳 (직접 호출 금지 → `start()`가 내부적으로 호출)                         |
| `start()`                         | 새 쓰레드를 시작해서 `run()`을 호출. 실제 OS 수준의 쓰레드 생성됨.  |

### 2. 정지 / 대기 🔍
| 메서드            | 설명                 |
| ------ | ----------------------------- |
| `	sleep(long ms)`      | 쓰레드 일시 정지 (휴식), CPU 사용 양보 |
| `	yield()`      | 현재 쓰레드 CPU 양보, 실행 대기 중인 다른 쓰레드에 기회 줌 |
| `interrupt()`  | 	일시 정지된 쓰레드를 깨우거나 인터럽트 신호 전달 |
- sleep는 일정 시간 동안 쓰레드를 멈춘상태로 만들고
- yield는 일시적 CPU 양보함.(우선순위가 높거나 동일한 쓰레드가 있으면 먼저 실행하게 양보)
- interrupt는 정지 또는 대기상태인 쓰레드의 InterruptedException를 발생시킴(재개할지 안할지는 catch를 통해 결정)

### 3. 우선순위 🔍
| 메서드            | 설명                 |
| ------ | ----------------------------- |
| `setPriority()`  | 쓰레드 **우선순위** 지정 (1\~10, 기본값 5)  |
| `getPriority()`  | 쓰레드 우선순위를 확인 (1\~10, 기본값 5)  |
- 실행 대기 중인 여러 쓰레드 중 우선순위가 높은 쓰레드가 선점되어 실행될 수 있으나, 상대적으로 낮은 쓰레드는 계속 대기상태에 걸릴 수 있음.
- 즉시 처리해서 결과를 답해줘야하는 핵심 비즈니스 로직을 처리하고, 메일 또는 SMS 발송등의 부가적인 작업들은 순위가 낮은 쓰레드로 처리하면 유리함. (하지만 무한 지연되지 않도록 하는것도 중요)

### 4. 데몬쓰레드
- 데몬 쓰레드의 생성
 ```
 Thread t = new Thread(...);
 t.setDaemon(true); // 데몬쓰레드로 변경
 t.start();쓰레드가 락을 획득하기 전에, 자신 캐시에 있는 객체(데이터)가 최신(valid) 상태인지 확인
 ```
- 데몬쓰레드는 메인로직과 일반쓰레드가 종료되면 데몬쓰레드의 로직 완료여부와 관계없이 종료.
- check 🔍
    - 가비지 컬렉터 (GC) / 로그 처리 쓰레드 / 모니터링 또는 감시 스레드 / 스케줄러 등
    - 중요한 작업보다는 간단하고 보조적인 작업을 처리함.
    - 메일 발송을 쓰레드에서 처리한다고 한다면, 데몬으로 할경우 발송을 못해도 종료됨.
 
## 3. 쓰레드락 
 - 쓰레드락
   - 여러 쓰레드가 동시에 하나의 공유 자원(예: 변수, 데이터베이스, 파일 등)에 접근할 때, 데이터가 엉키거나 깨지지 않도록 ‘한 번에 한 명만’ 접근하도록 막는 방법
   - 동일한 객체를 접근할때 필드값이나 클래스 변수를 동시에 사용해서 경쟁상태가 발생하는 것을 막기 위함.
   - 쓰레드락을 사용하지 않는 경우 최종 객체가 어떤 상태인지 확실하지 않음.
   - `synchronized`등을 통해서 한번에 한 쓰레드만 접근하도록 유도.
 - 쓰레드락 - 캐시 - CPU🔍
   1) 쓰레드가 락을 획득하기 전에, 자신 캐시에 있는 객체(데이터)가 최신(valid) 상태인지 확인
   2) 쓰레드락을 획득하여 캐시에 들어와있는 객체를 소유하게되고,
   3) 소유한 객체는 다른 쓰레드에서 사용 불가 상태,(무효화)
   4) 소유한 쓰레드가 로직을 처리하고,
   5) 락을 해제하면, 수정된 것은 메모리에 저장
   6) CPU는 캐시 일관성 프로토콜(MESI 등)을 활용해서 다른 쓰레드 캐시를 업데이트하거나 무효화
   7) 다른 쓰레드가 다시 메모리에서 접근
