## 1. 전송 계층 
### 1. 전송계층
 - 컴퓨터 간이 아니라, 컴퓨터 안의 프로그램(애플리케이션)끼리 정확하게 데이터를 주고받게 해주는 계층
 - 역할 
   - 데이터를 쪼개고 붙임 (분할 & 재조립)
   - 신뢰성 보장 (오류 제어)
   - 흐름 조절
   - 통신 대상 지정 (포트 번호 사용)

### 2. 프로토콜 종류
  | 프로토콜 | 특징              |
   | ---- | --------------- |
   | TCP  | 신뢰성 보장, 느리지만 안전 |
   | UDP  | 신뢰성 없음, 빠르고 단순  |

### 3. TCP 세그먼트
 - TCP 세그먼트(segment)는 전송계층이 네트워크로 보내는 데이터 전송 단위
 - TCP 헤더는 제어 정보 (누구에게 보낼지, 순서, 확인 등)
 - 데이터(payload)는 실제 내용 (예: HTTP 메시지 등)
    ```
    TCP 세그먼트 = TCP 헤더 + 데이터(payload)
    ```
   
### 4. TCP 헤더
| 필드 이름            | 한글 이름     | 설명                              |
| ---------------- | --------- | ------------------------------- |
| Source Port      | 출발지 포트 번호 | 데이터를 보낸 쪽 포트 번호                 |
| Destination Port | 목적지 포트 번호 | 데이터를 받을 쪽 포트 번호                 |
| Sequence Number  | 순서 번호     | 전송하는 데이터의 순서 지정                 |
| Acknowledgment Number | 확인 응답 번호  | 수신한 데이터 다음에 기대하는 순서 번호          |
| Header Length    | 헤더 길이     | TCP 헤더의 크기 (4비트, 단위: 32비트 워드)   |
| Flags (Control Bits) | 제어 플래그    | SYN, ACK, FIN 등 통신 상태 제어용 비트    |
| Window Size      | 윈도우 크기    | 수신 가능한 버퍼 용량 (흐름 제어에 사용)        |
| Checksum         | 체크섬       | 오류 검출을 위한 값 (헤더와 데이터 포함)        |
| Urgent Pointer   | 긴급 포인터    | 긴급 데이터의 끝 위치 (긴급 모드에서만 사용)      |
| Options          | 옵션        | 선택적인 확장 정보 (예: 윈도우 확장, 타임스탬프 등) |

## 2. 핸드셰이크
### 1. 플래그
 - TCP 연결 상태를 관리하거나 통신 흐름을 제어하기 위한 1비트짜리 플래그
 - 소통할때 켜고(1), 끄고(0)하는 방식으로 조합하여 사용함.
 - 플래그 내용

 | 플래그 이름  | 한글 이름        | 역할 및 설명                                     |
 | ------- | ------------ | ------------------------------------------- |
 | **URG** | 긴급 데이터 표시    | Urgent Pointer 필드를 사용한다는 신호 (대부분 무시됨)       |
 | **ACK** | 확인 응답        | Acknowledgment Number 필드가 유효함을 의미           |
 | **PSH** | 즉시 전달 요청     | 받은 데이터를 애플리케이션에 즉시 넘기도록 요청                  |
 | **RST** | 연결 강제 종료     | 비정상 상태일 때 연결을 즉시 끊을 때 사용 (예: 포트가 닫혀 있을 때)   |
 | **SYN** | 연결 요청        | 연결 시작 요청 (3-way 핸드셰이크에서 사용)                 |
 | **FIN** | 연결 종료        | 연결 종료 요청 (4-way 핸드셰이크에서 사용)                 |
 | **ECE** | ECN-Echo     | 혼잡 알림 수신 여부 (ECN 사용 시, 혼잡 신호로 사용)           |
 | **CWR** | 혼잡 윈도우 줄임 표시 | ECE에 응답하기 위한 신호 (Congestion Window Reduced) |
 | **NS**  | Nonce Sum    | ECN의 보안 확장용 (거의 사용되지 않음)                    |

### 2. 3방향 핸드셰이크
 | 단계 | 송신 주체 | 수신 주체 | 설명                      | 플래그              |
 | -- | ----- | ----- | ----------------------- | ---------------- |
 | 1  | 클라이언트 | 서버    | 연결 요청 (연결 시작 의사 표시)     | SYN = 1          |
 | 2  | 서버    | 클라이언트 | 요청 수락 및 응답, 연결 준비 상태 표시 | SYN = 1, ACK = 1 |
 | 3  | 클라이언트 | 서버    | 연결 확인 및 최종 응답           | ACK = 1          |

### 3. 4방향 핸드셰이크
 | 단계 | 송신 주체         | 수신 주체       | 설명                     | 플래그     |
 | -- | ------------- | ----------- | ---------------------- | ------- |
 | 1  | 한쪽 (예: 클라이언트) | 상대방 (서버)    | 연결 종료 요청 (더 이상 데이터 없음) | FIN = 1 |
 | 2  | 상대방 (서버)      | 요청자 (클라이언트) | 종료 요청 수락 및 확인 응답       | ACK = 1 |
 | 3  | 상대방 (서버)      | 요청자 (클라이언트) | 자신도 연결 종료 준비 (종료 요청)   | FIN = 1 |
 | 4  | 요청자 (클라이언트)   | 상대방 (서버)    | 종료 확인 응답               | ACK = 1 |

## 3. TCP 에러 제어
### 1. Stop-and-Wait ARQ
 - 동작 방식
   - 송신자는 한 번에 한 프레임(또는 세그먼트)만 보냄.
   - 수신자로부터 **ACK(확인 응답)**을 받을 때까지 기다림
   - ACK를 받으면 다음 프레임 전송.
 - 장점 : 구현이 간단함.
 - 단점 : 전송 중 대기 시간이 길어지므로 채널 이용률이 낮고 왕복 지연 시간이 긴 네트워크에 비효율적.

### 2. Go-Back-N ARQ
 - 동작 방식
   - 송신자는 최대 N개의 프레임을 연속해서 보낼 수 있다(윈도우 크기 N).
   - 수신자가 오류를 발견하면, 그 프레임부터 모든 이후 프레임을 무조건 재전송하라고 요청한다.
 - 장점: Stop-and-Wait보다 채널 효율이 훨씬 높음.
 - 단점: 오류 발생 시 재전송되는 프레임이 많아져서 비효율적일 수 있음.

### 3. Selective Repeat ARQ
 - 동작 방식
    - 송신자가 최대 N개의 프레임을 연속 전송 가능.
    - 수신자는 오류가 있는 프레임만 선택적으로 재전송 요청한다.
    - 정상 수신된 프레임은 버퍼에 저장 후 순서대로 재조립.
 - 장점: 오류가 발생해도 필요한 프레임만 재전송하므로 효율적임.
 - 단점: 구현 복잡도가 높고, 수신 측 버퍼 관리가 까다로움.

## 4. TCP 흐름 제어
### 1.수신 윈도우(Receive Window) 
 - 수신 측이 한 번에 받을 수 있는 데이터 양
 - 수신자가 자신의 버퍼 여유 공간 크기를 송신자에게 알려주는 신호
 - 수신자의 처리 능력에 맞춰 송신량을 조절하도록 유도
 - 수신자 과부하 방지를 위한 피드백 메커니즘
 - 동작 원리
   - TCP 헤더의 윈도우 크기(Window Size) 필드에 현재 수신 가능 용량을 명시
   - 이 값이 클수록 송신자는 더 많은 데이터를 보내도 됨
   - 값이 0이면 수신자가 바빠서 더 이상 데이터 받을 수 없음을 의미

### 2. 슬라이딩 윈도우(Sliding Window)
 - 송신자가 한 번에 보낼 수 있는 데이터 양
 - 송신 윈도우가 커지면 더 많은 데이터를 연속 전송 가능
 - 윈도우가 작으면 송신량 제한
 - 동작 원리
    - 윈도우 크기만큼 데이터를 전송한 후,
    - 수신자로부터 받은 ACK에 따라 윈도우가 앞으로 이동(슬라이딩)하면서 새로운 데이터를 전송할 수 있게 됨

### 3. TCP 흐름 제어의 동작 과정
 - 수신자가 자신의 버퍼 여유 공간(윈도우 크기)을 송신자에게 알려줌.
 - 송신자는 그 크기만큼 데이터를 보내기 시작함. (슬라이딩 윈도우 크기 설정)
 - 수신자는 받은 데이터를 처리하면서 버퍼 공간이 생기면, 그 새로운 공간 크기를 다시 송신자에게 알려줌
 - 송신자는 다시 그 정보를 참고해 데이터를 계속 보냄

## 5. TCP 혼잡 제어
### 1. 느린 시작 임계값 (Slow Start Threshold, ssthresh)
 - TCP가 느린 시작 단계에서 혼잡 회피 단계로 전환하는 기준점
 - 처음에는 윈도우 크기(Congestion Window, cwnd)를 작게 시작해서 지수적으로 증가시키는 느린 시작 단계
 - cwnd(윈도우크기)가 ssthresh(느린 시작 임계값) 값에 도달하면, 성장 속도를 지수적 → 선형적으로 바꾸고, 혼잡 회피 단계로 넘어간다

### 2. 배수적 감소 (Multiplicative Decrease)
 - 혼잡이 감지되었을 때(예: 패킷 손실 발생),
 - 윈도우 크기를 크게 줄여 네트워크 부담을 완화하는 기법
 - 일반적으로 cwnd를 절반으로 감소시킴.
 - 동시에 ssthresh도 현재 cwnd 값의 절반으로 재설정

### 3. 흐름
| 단계           | 설명                           |
| ------------ | ---------------------------- |
| 느린 시작        | cwnd를 1부터 시작해 지수적으로 증가       |
| ssthresh 도달  | 느린 시작 → 혼잡 회피로 전환 (증가 속도 완화) |
| 혼잡 발생        | cwnd를 절반으로 줄임 (배수적 감소)       |
| ssthresh 재설정 | ssthresh = 감소된 cwnd 값으로 업데이트 |


## 6. 애플리케이션의 출입구: 포트 번호
### 1. 포트번호
 - 한 컴퓨터에 여러 프로그램(예: 웹서버, 이메일 클라이언트, FTP)이 동시에 네트워크 통신을 할 때,
 - 포트 번호를 통해 “어떤 프로그램이 이 데이터를 받는지” 구분해 주는 역할

### 2.Well-Known 포트
| 포트번호   | 프로토콜   | 용도                                                  |
| ------ | ------ | --------------------------------------------------- |
| 20, 21 | FTP    | 파일 전송(File Transfer Protocol)                       |
| 22     | SSH    | 보안 원격 접속(Secure Shell)                              |
| 23     | Telnet | 원격 터미널 접속                                           |
| 25     | SMTP   | 이메일 전송(Simple Mail Transfer Protocol)               |
| 53     | DNS    | 도메인 이름 서비스(Domain Name System)                      |
| 67, 68 | DHCP   | 동적 호스트 구성 프로토콜(Dynamic Host Configuration Protocol) |
| 80     | HTTP   | 웹 서비스(비암호화)                                         |
| 110    | POP3   | 이메일 수신(Post Office Protocol v3)                     |
| 143    | IMAP   | 이메일 수신(Internet Message Access Protocol)            |
| 443    | HTTPS  | 웹 서비스(암호화된 HTTP)                                    |
| 445    | SMB    | 윈도우 파일 공유(Server Message Block)                     |
| 3389   | RDP    | 원격 데스크톱(Remote Desktop Protocol)                    |


## 7. UDP
### 1. UDP 개요
 - 전송 속도가 빠르지만 패킷의 도착 순서나 손실에 대한 보장이 없음.
 - 몇 개의 패킷이 손실되더라도 전체 서비스 품질에 큰 영향을 미치지 않는 경우 UDP 사용
 - 
 - 특징
   - 비연결성: 연결 설정 없이 데이터를 바로 보냄
   - 빠름: 헤더가 간단하고, 오류 제어나 재전송 같은 기능이 없음
   - 신뢰성 낮음: 데이터 손실, 중복, 순서 뒤바뀜 등을 처리하지 않음
   - 용도: 실시간 통신(음성, 영상 스트리밍), 게임, DNS 쿼리 등 지연 최소화가 중요한 곳에 사용

### 2. TCP/UDP
| 특징    | TCP               | UDP         |
| ----- | ----------------- | ----------- |
| 연결성   | 연결 지향             | 비연결         |
| 신뢰성   | 신뢰성 보장(재전송, 확인 등) | 신뢰성 보장하지 않음 |
| 속도    | 느림                | 빠름          |
| 헤더 크기 | 20바이트 이상          | 8바이트        |

### 3. UDP 데이터그램
 - UDP 헤더가 데이터에 부착되면 'UDP 데이터그램' <-> TCP는 TCP 세그먼트
 - UDP 헤더

   | 필드 이름                       | 크기   | 설명                                 |
   | --------------------------- | ---- | ---------------------------------- |
   | 출발지 포트번호 (Source Port)      | 2바이트 | 데이터를 보낸 애플리케이션의 포트 번호              |
   | 목적지 포트번호 (Destination Port) | 2바이트 | 데이터를 받을 애플리케이션의 포트 번호              |
   | 길이 (Length)                 | 2바이트 | UDP 헤더 + 데이터의 전체 길이 (바이트 단위)       |
   | 체크섬 (Checksum)              | 2바이트 | 데이터가 손상됐는지 확인 (선택적 필드지만 IPv6에선 필수) |

## 8. SSL/TLS
### 1. SSl/TLS 위치
 - 계층 구분
   - TCP: 전송계층 (4계층)
   - TLS: 표현 계층 (6계층), 또는 TCP 위의 보안 계층
 - 현실에서는 OSI 계층이 완벽히 적용되지 않아서 TLS는 TCP 위에 있는 중간 계층처럼 작동함.
 - TCP 위에서 동작하는 보안 프로토콜로 봐야함.

### 2. SSL/TLS
  - SSL (Secure Sockets Layer)
    - 초기 보안 프로토콜
    - 넷스케이프가 개발 (1990년대)
    - 웹 브라우저와 서버 간 통신을 암호화해서 중간에서 도청이나 변조되지 않도록 함
    - 현재는 더 이상 사용되지 않음 (보안 취약점 때문에)
 - TLS (Transport Layer Security)
    - SSL의 후속 버전 (표준화)
    - 현재는 TLS 1.2 또는 TLS 1.3이 널리 사용됨
    - SSL보다 훨씬 더 강력한 보안과 최적화된 성능 제공
    - HTTPS, 메일, VPN 등 다양한 곳에 사용

### 3. 대칭키/비대칭키
| 항목    | 대칭키                    | 비대칭키                    |
| ----- |------------------------|-------------------------|
| 키 개수  | 1개 (같은 키로 암호화/복호화)   | 2개 (암호화용 공개키, 복호화용 개인키) |
| 속도    | 빠름                     | 느림                      |
| 보안    | 키 유출 위험 있음             | 키 분리로 보안성 높음            |
| 사용 예시 | 파일 암호화, VPN, TLS 내부 세션키 | TLS 핸드셰이크, 디지털 서명 등     |

### 3. 흐름
| 순서 | 단계    | 메시지         | 역할 및 설명                               |
|----| ----- | ----------- | ------------------------------------- |
| 1  | 클라이언트 | ClientHello | 클라이언트가 지원하는 암호화 방식, 랜덤 값 등을 서버에 전송    |
| 2  | 서버    | ServerHello | 서버가 선택한 암호화 방식, 랜덤 값 전송               |
| 3  | 서버    | 서버 인증서 전송   | 서버가 자신의 신원을 증명하는 디지털 인증서 전달           |
| 4  | 클라이언트 | 인증서 검증      | 클라이언트가 서버 인증서의 유효성(발급기관, 유효기간 등) 확인   |
| 5  | 클라이언트 | 세션키 생성 및 전송 | 클라이언트가 세션키(대칭키)를 생성해 서버 공개키로 암호화하여 전송 |
| 6  | 서버    | 세션키 복호화     | 서버가 자신의 개인키로 세션키 복호화                  |
| 7  | 양측    | 완료 메시지 교환   | 세션키로 암호화된 데이터 교환 준비 완료 알림             |



