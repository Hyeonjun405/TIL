# 1. 절차지향 (Procedural Programming)
## 1. 정의
-  프로그램을 **순차적인 절차(Procedure)**와 **함수(Function)**의 흐름으로 구성하는 전통적인 프로그래밍 패러다임
- 데이터를 중심으로 여러 **절차(로직)**가 그 데이터를 처리하는 구조로 되어 있음

## 2. 핵심 개념

| 항목                             | 절차지향 프로그래밍 설명                                                              |
| ------------------------------ | -------------------------------------------------------------------------- |
| 중심 단위<br>(Unit of Composition)    | 함수(Function)<br>프로그램은 기능 단위(절차)로 구성됨                                       |
| 데이터 관리 방식<br>(Data Handling)      | 전역 변수(Global Variable)와 지역 변수(Local Variable) 중심<br>데이터는 함수와 분리되어 존재함      |
| 행동 정의 방식<br>(Behavior Definition) | 함수 호출(Call by Value/Reference)을 통해 명령 실행<br>상태(state)는 함수 호출 시 인자로 전달      |
| 구성 원리<br>(Design Principle)       | Top-Down 설계<br>상위 기능부터 정의한 후 세부 구현으로 분해 (Divide and Conquer)               |
| 설계 원칙<br>(Design Philosophy)      | 명령 기반(Command-based), 상태 변화 중심(State Mutation), 순차적 처리(Sequential Logic)   |
| 관계 구성<br>(Component Relationship) | 함수들이 전역 상태를 공유하며 명시적 호출(Explicit Call)로 흐름을 제어<br>함수 간 결합(Coupling) 가능성 높음 |


# 2. 객체지향 (Procedural Programming)
## 1. 정의
-  프로그램을 객체(Object) 단위로 구성하고, 객체가 **데이터(State)**와 **동작(Method)**를 함께 포함하며, **객체 간 메시지 전달(Message Passing)**을 통해 협력하여 문제를 해결하는 프로그래밍 패러다임
- 현실 세계의 개념을 추상화(Abstraction) 하여 소프트웨어 구조에 적용함.

## 2. 핵심 개념

| 항목                             | 객체지향 프로그래밍 설명                                                                                         |
| ------------------------------ | ----------------------------------------------------------------------------------------------------- |
| 중심 단위<br>(Unit of Composition)    | 객체(Object)<br>상태(State)와 행위(Behavior)를 함께 가지는 단위로 구성됨                                                 |
| 데이터 관리 방식<br>(Data Handling)      | 객체 내부의 필드(Field)로 상태를 보존<br>접근제어자(Access Modifier)로 외부 접근을 제어 (ex. private, protected)                |
| 행동 정의 방식<br>(Behavior Definition) | 객체 내부의 메서드(Method)를 통해 행위 정의<br>**메시지(Message) 전달**을 통해 객체 간 협력                                       |
| 구성 원리<br>(Design Principle)       | 역할 기반 설계(Role-based Design)<br>객체는 책임(Responsibility)을 가지며 상호 협력으로 문제 해결                              |
| 설계 원칙<br>(Design Philosophy)      | 캡슐화(Encapsulation), 추상화(Abstraction), 상속(Inheritance), 다형성(Polymorphism)<br>→ SRP, OCP 등 SOLID 원칙과 밀접 |
| 관계 구성<br>(Component Relationship) | 객체 간 메시지 전달(Message Passing)을 통한 느슨한 결합(Loose Coupling)<br>인터페이스(Interface)를 통한 의존성 역전 및 추상화 수준 유지    |

# 3. 객체지향의 특징

## 1. 객체지향 프로그래밍의 특징

| 개념                     | 설명                  | CS 용어 설명              |
| ---------------------- | ------------------- | ---------------------------- |
| **추상화(Abstraction)**   | 복잡한 현실을 단순한 모델로 표현  | 필요한 정보만 노출하고, 나머지는 숨김        |
| **캡슐화(Encapsulation)** | 데이터와 메서드를 하나로 묶고 보호 | 객체 내부 상태 보호, 인터페이스를 통한 접근 제한 |
| **상속(Inheritance)**    | 기존 클래스를 확장해 재사용     | 코드 중복 감소, ‘IS-A’ 관계 표현       |
| **다형성(Polymorphism)**  | 같은 메시지에 다른 동작 수행    | 인터페이스/메서드 오버라이딩으로 유연성 제공     |

## 2. 캡슐화 (Encapsulation)
### 1. 특징
- 데이터 보호 및 객체의 일관성 유지를 위함.
- 객체의 데이터(속성)와 기능(메서드)을 하나로 묶고, 내부 상태는 숨기며 외부에는 필요한 기능만 노출함.
- Java에서는 `private` 필드 + `public getter/setter` 메서드
```
public class ScoreBoard {
    private int score; // private로 외부에서는 접근불가

    public int getScore() {
        return score; // 스코어보드(객체)의 점수를 확인하기 위한 방법
    }

    public void addScore(int points) {
        if (points > 0) {
            score += points; //스코어보드(객체)의 점수를 추가하는 방법
        }
    }
}
```

### 2. Check 🔍
- 절차지향 프로그래밍에서는 전역 변수 또는 공용 데이터를 여러 함수가 공유하게 되며, 이로 인해 한 함수가 데이터를 의도치 않게 변경하거나 초기화할 경우, 전체 시스템의 동작에 예상치 못한 상황이 발생할 수 있음.
-  OOP는 필드와 해당 데이터를 조작하는 메서드 하나의 객체 단위로 캡슐화(Encapsulation)하고, 외부에서는 내부 상태에 직접 접근하지 못하도록 접근제어자를 사용하여 객체가 자율성과 독립성을 가지도록함.



## 3. 상속 (Inheritance)
### 1. 특징
- 코드 재사용과 계층적 관계 표현
- 기존 클래스(부모)의 속성과 기능을 물려받아 새로운 클래스를 만듬.
- Java에서는 `extends` 키워드 사용
```
class Animal {
    void eat() { System.out.println("먹는다"); } 
  }
 
  class Dog extends Animal {
    void bark() { System.out.println("멍멍"); }   
  }

  // 사용
  Dog dog = new Dog();
  dog.eat();   // → "먹는다" ← 상속된 부모의 기능
  dog.bark();  // → "멍멍"
```

### 2. check 🔍
-  절차지향에서는 함수가 사용하는 변수들이 전역 또는 외부 상태에 의존하고, 함수의 실행이 전체 로직의 특정 위치에 고정되어 있어, 해당 함수를 다른 상황에서 독립적으로 재사용하기 힘듬.
- 객체지향은 상속을 통해 공통 기능을 일반화하고, 각 객체가 자신의 문맥에 맞게 해당 기능을 확장하거나 재정의함으로써, 유지보수성과 재사용성을 높임.




## 4. 추상화 (Abstraction)
### 1. 특징
- 복잡한 내부는 숨기고, 외부에는 필요한 인터페이스(사용 방법)만 보여주는 것
- ‘복잡한 것은 감추고 간단하게 다루자’는 원리
- Java에서는 `abstract class`, `interface`
```
 // 동물 인터페이스
 public interface Animal { 
     public void sound();
 }

 public class Dog implements Animal{
     @Override
     public void sound() {
         System.out.println("강아지는 멍멍");
     }
  }
```
### 2. check 🔍
- 절차지향 프로그래밍에서는 함수의 역할과 사용 목적을 이해하려면 전체 프로그램의 흐름과 맥락(전후 호출 관계, 데이터 흐름)을 파악해야함. 이는 코드가 커질수록 복잡도가 증가하고 유지보수가 어려워지는 원인
- 객체지향 프로그래밍에서는 인터페이스나 추상 클래스를 통해 각 객체의 역할과 계약을 명확하게 정의하고, 외부에 불필요한 구현 세부사항을 은닉(정보 은닉)함으로써 시스템의 구조를 단순하게 이해하고 유연하게 확장할 수 있도록 함.

## 5. 다형성 (Polymorphism)
### 1. 특징
- 인터페이스를 통일하여 공통으로 필요한 기능을 정의하고 유연한 설계함.
- 하나의 메서드나 객체가 여러 형태로 동작함.
- 자바에서는 `extends` + `Override`, `interface` 등으로 구현
```
 class Animal {
      void speak() { System.out.println("동물 소리"); }
  }
  
  class Cat extends Animal {
      @Override
      void speak() { System.out.println("야옹"); }
  }

  // 사용
  Animal animal = new Cat();
  animal.speak();  // → "야옹" ← 다형성
```
### 2. Check 🔍
- 절차지향 프로그래밍에서는 타입 개념이 부족하거나 명확하지 않아,
  기능 분기나 조건에 따른 동작 변경을 위해 if/else, switch 같은 제어문을 많이 사용함. 이로 인해 기능이 추가되거나 변경될 때마다 코드 전반에 영향을 미쳐 유지보수가 어려워짐.
- 객체지향 프로그래밍은 인터페이스와 클래스라는 ‘타입’ 개념을 도입하여, 클라이언트는 구체적인 구현체가 아닌 타입(인터페이스)에 의존함.
  따라서 내부 구현을 바꾸거나 새로운 기능을 추가할 때도 기존 코드를 수정하지 않고, 새로운 구현체를 만들어 쉽게 확장할 수 있도록 설계 가능함.

# 4. 절차지향 VS 객체지향 🔍
- 절차지향은 소프트웨어 개발 초기 패러다임으로, 특정한 문제를 정해진 순서대로 빠르고 정확하게 처리하는 데 최적화되어 있음. 이는 하드웨어 성능이 제한적이고, 상대적으로 단순한 문제를 해결하는 데 적합함.

- 객체지향은 하드웨어 성능 향상과 시스템 복잡도 증가에 대응하여 등장함. 복잡하고 다양한 요구사항을 가진 대규모 시스템을 ‘객체’라는 단위로 분리하여 관리하고 유지보수, 확장성을 높이는 데 목적을 둔 패러다임, 이를 통해 객체를 수정함으로써 빠른 수정과 개발을 가능하게함.
 