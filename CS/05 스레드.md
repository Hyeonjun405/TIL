※ CS/OS로 해당 내용 분리 및 재정리

## 1. 스레드
### 1. 스레드
- 스레드(Trhead)는 프로세스에서 작업을 실행하는 단위
- 스레드 한개가 들어가면 단일 스레드(SingleThread), 다수의 스레드가 들어가면 다중 스레드(Multi Thread)
- 다중 스레드(MUlti Thread)는 다수의 실행을 병렬로 진행할 수 있음.

### 2. 다중스레드 vs 다중프로세스
-  "다중 스레드(Multithreading)"와 "다중 프로세스(Multiprocessing)"는 병렬성과 동시성 처리를 위한 개념
    - 다중 스레드는 하나의 프로세스 내부에서 여러 스레드가 메모리를 공유하며 동시에 실행됨
    - 다중 프로세스는 여러 개의 독립된 프로세스가 메모리/자원 분리 상태로 각각 실행됨
- 병렬성과 동시성

| 구분                    | 의미                              | 예시                      |
| --------------------- | ------------------------------- | ----------------------- |
| **병렬성 (Parallelism)** | **물리적으로 동시에 실행**                | 2개의 CPU가 각각 다른 작업 수행    |
| **동시성 (Concurrency)** | **논리적으로 동시에 실행 (순차적으로 쪼개어 실행)** | 1개의 CPU가 빠르게 작업을 번갈아 수행 |

- 비교

| 항목   | 다중 프로세스 (Multiprocessing)  | 다중 스레드 (Multithreading) |
| ------------------ | --------------- | --------------------------------- |
| **단위**             | 프로세스 (Process)                 | 스레드 (Thread)     |
| **메모리**            | **독립된 주소 공간** (heap, stack 분리) | **공유된 주소 공간** (heap 공유, stack 분리) |
| **통신 방식**          | IPC (파이프, 소켓, 메시지큐 등) 필요    | 공유 변수, 동기화 객체 등 직접 접근 가능          |
| **컨텍스트 전환 비용**     | **크다 (커널 수준)**      | **작다 (경량)**  |
| **안정성 (crash 격리)** | 하나 죽어도 다른 프로세스 영향 없음      | 하나 죽으면 전체 프로세스 위험 가능              |
| **디버깅/관리**         | 상대적으로 단순          | 동기화 이슈, 디버깅 어려움   |
| **스케줄링 단위**    | OS 스케줄러가 관리    | OS 스케줄러 + 사용자 쓰레드 가능 |
| **사용 예시**   | Chrome 탭, DB 서버 프로세스, 백그라운드 데몬 | 게임 루프, 웹 서버 쓰레드 풀, 병렬 계산   |

※ **다중 스레드(multithreading)**는 코드 영역, 데이터 영역(힙)을 공유하므로 메모리 사용량이 적고,
**다중 프로세스(multiprocessing)**는 각자 독립된 메모리 공간을 가지므로 메모리 사용량이 많음.

※ 다중 프로세스를 사용하는 언어나 시스템

| 언어나 시스템              | 멀티프로세스 사용 이유              |
| -------------------- | ------------------------- |
| **Python (CPython)** | GIL로 인한 멀티스레드 병렬성 불가      |
| **Node.js**          | 이벤트 루프 기반이라 멀티스레드 어려움     |
| **Erlang / Elixir**  | 내장된 가벼운 프로세스 모델 (BEAM VM) |
| **Apache (Prefork)** | 요청 간 격리 필요                |
| **Redis, DB**        | 데이터 복사, 백업 등에서 fork 사용    |
| **Docker, 쿠버네티스 등**  | 기본 단위가 프로세스 컨테이너          |


## 2. JVM - OS - CPU
### 1. CPU - OS - JVM 흐름 🔍
- CPU 싱글코어 / JVM 싱글 스레드
    1) JVM : OS에 네이티브 스레드 1개 생성 요청
    2) OS : 커널 스레드 1개를 생성하고 대기 상태에 둠
    3) JVM :  이 싱글 스레드를 실행할 자바 바이트코드를 관리
    4) OS : 스케줄러는 유일한 스레드를 CPU 코어에 할당해 실행
    5) CPU : 이 스레드의 명령어를 순차적으로 실행

- CPU가 멀티코어 / JVM 멀티스레드 실행
    1) 개발자: 자바 코드에서 new Thread() 호출
    2) JVM: OS에 네이티브 스레드 요청
    3) OS: 커널 수준의 쓰레드 생성 → CPU 스케줄러에 등록
    4) CPU: OS 스케줄러가 선택한 스레드를 코어에 할당해 실행

- CPU가 멀티코어 / JVM 스레드풀
    1) JVM: 스레드풀 크기만큼 OS에 네이티브 스레드 생성 요청 → OS가 커널 스레드 생성
    2) OS: 생성된 커널 스레드들은 초기엔 대기 상태 (대기큐에 등록)
    3) 개발자: 자바 코드에서 스레드풀의 쓰레드를 할당받아 작업(run()) 시작 요청
    4) JVM: 할당된 자바 쓰레드가 실행할 바이트코드(자바 코드)를 관리
    5) OS: OS 스케줄러가 해당 네이티브 스레드를 CPU 코어에 스케줄링하여 실행

### 2. 네이티브 스레드와 CPU 멀티코어, JVM 멀티스레드 
- JVM의 각 자바 스레드는 내부적으로 OS의 네이티브 스레드 하나와 1:1 매핑.
- OS의 네이티브 스레드는 CPU의 멀티코어 자원을 활용해서 병렬 실행함.
- 즉, 네이티브 스레드는 JVM과 CPU 코어 사이에서 스레드 단위 실행을 연결해주는 ‘실제 실행 단위’ 역할
- 네이티브 스레드와 JVM스레드는 일치하지만, 네이티브 스레드와 CPU의 코어는 스레드 스케줄러에 따라 움직이는 것이기 떄문에 일치하지 않음.

### 3. OS 스케줄러 
  - 부하 분산 : OS 스케줄러는 CPU 코어의 부하가 골고루 분산되도록 스레드를 할당해서, 특정 코어에 작업이 몰려 과부하가 걸리지 않게 함
  - 캐시 유지 최적화 : 스레드가 같은 코어에 계속 붙어 실행되도록 하여 캐시 효율을 유지하려고 함 하지만 완벽한 고정은 아니고 필요에 따라 코어 이동 발생

### 4. 쓰레드 활용
  - 스레드 A가 코어 1에서 실행되다가, 다음 시간엔 코어 3에서 실행된다고 가정하면, 🔍
    - 코어 1의 캐시에 저장되어 있던 데이터/명령어는 코어 3의 캐시에 없기 때문에, 코어 3은 다시 메모리에서 데이터를 불러와야 함 → 이것이 캐시 미스(cache miss)
    - 그 다음 캐시 미스가 자주 발생하면 CPU는 메모리에서 데이터를 읽느라 대기 시간이 길어지고,결과적으로 전체 실행 성능이 떨어짐
   
  - 쓰레드와 캐시를 효과적으로 사용하려면, 🔍
   - 내부적인 소스는 비슷한 메모리주소를 쓸법한 객체들은 동시에 사용 및 호출해서 캐시미스를 줄이고
   - 동일한 캐시 라인을 사용하는 작업끼리는 순차적으로 뭉쳐서, 캐시 일관성 유지 비용(coherence overhead)을 키우고,
   - 서로 독립적인 데이터를 다루면, 스레드를 분리해서 병렬로 처리하는 것이 가장 효과적