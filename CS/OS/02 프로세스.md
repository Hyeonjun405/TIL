## 1. 프로세스
- 다중 프로그래밍 환경에서 여러 프로그램이 동시에 메모리에 적재되어 CPU를 공유하며 병행 실행되기 시작했고, 이 과정에서 각 실행 중인 프로그램을 구분하고 자원 할당/보호/스케줄링을 위해 운영체제가 도입한 관리 단위가 `프로세스(Process)`
- 프로세스의 일반적인 정의는 `실행중인 프로그램`

## 2. 프로그램과 프로세스
- 프로그램은 컴파일한 코드와 초기화 전역변수, 문자열과 문자열 상수 등 정적 데이터를 포함하는 디스크에 존재하는 정적인 객체
- 프로세스는 메모리구조를 이루고 프로그앰 카운터나 레지스터처럼 현재 어떤 자원을 사용하는지 관련 정보가 들어있는 동적인 객체

## 3. 프로세스의 일반적인 메모리 구조
```
 +----------------------------+
 | 코드 영역 (Text Segment)     |
 +----------------------------+
 | 데이터 영역 (Data Segment)   |
 | - 초기화된 데이터             |
 | - 초기화되지 않은 데이터 (BSS) |
 +-----------------------------+
 | 힙 영역 (Heap)               |
 +-----------------------------+
 | **자유 영역 (Free Area)**     |  ← 동적 할당 가능한 여유 공간 (힙과 스택 사이) 
 +-----------------------------+
 | 스택 영역 (Stack)             |
 +-----------------------------+
```
- 코드 영역: 프로그램 명령어들이 저장되는 영역. 보통 읽기 전용.
- 데이터 영역: 전역 변수, 정적 변수들이 저장됨. 초기화 여부에 따라 나눔.
- 힙 영역: 런타임 중 동적 메모리 할당을 위한 영역.
- 자유 영역: 힙과 스택 사이에 남아있는 비할당 메모리 공간.
- 스택 영역: 함수 호출 시 생성되는 지역 변수, 매개변수, 리턴 주소 등이 저장됨.


## 4. 프로세스의 종류

| 분류 기준        | 분류 항목       | 설명                                 |
| ------------ | ----------- | ---------------------------------- |
| **역할(Role)** | 시스템(커널) 프로세스    | 운영체제 내부 기능 <br> 모든 시스템 메모리와 프로세서의 명령에 엑세스 할 수 있는 프로세스  |
|              | 사용자 프로세스    | 사용자가 실행한 앱 |
| **병행 수행 방식** | 독립 프로세스     | 다른 프로세스에 영향을 주지 않거나, 다른 프로세스의 영향을 받지 않는 병행 프로세스|
|              | 협력 프로세스| 다른 프로세스에 영향을 주거나, 다른 프로세스에 영향을 받는 병행 프로세스|


## 5. 프로세스 상태
- 운영체제에서 **프로세스 상태(Process States)**는 프로세스가 실행되는 동안 가질 수 있는 여러 단계(상태)

| 상태 이름               | 설명                            |
| ------------------- | ----------------------------- |
| **New (생성)**        | 프로세스가 생성되어 아직 준비되지 않은 상태      |
| **Ready (준비)**      | CPU 할당을 기다리는 상태, 실행 대기 중      |
| **Running (실행)**    | CPU를 할당받아 현재 명령어를 실행 중인 상태    |
| **Waiting (대기)**    | 입출력 완료 등 이벤트를 기다리는 상태 (블록 상태) |
| **Terminated (종료)** | 프로세스가 실행을 마치고 종료된 상태          |
- 흐름
 ```
 New → Ready → Running → Waiting → Ready → Running → Terminated
 ```
- New → Ready : 프로세스 생성 후 준비 상태로 전환
- Ready → Running : (dispatch) CPU 할당 받아 실행
- Running → Waiting : (block) I/O 등 이벤트 대기 위해 대기 상태로 전환
- Waiting → Ready : (timeout) 이벤트 완료 후 다시 실행 대기
- Running → Terminated : 작업 완료 후 종료
- 문맥전환은 CPU가 실행하는 프로세스를 교체하는 작업으로 교체 당하는 프로세스의 문맥은 보관하고 교체하는 프로세스의 문맥은 복원하는 과정

## 6. 프로세스 제어블록
- 프로세스 제어블록(PCB, Process Control black)은 프로세스의 정보를 담은 하나의 구조체
- 프로세스 ID, 프로세스 상태, 프로세스 주소, 크기등의 정보를 가지고 있음.
- 프로세스 제어블록의 내용

| 범주                  | 설명                                            |
| ------------------- | ----------------------------------------- |
| **프로세스 상태**         | 현재 상태 (Running, Ready, Blocked 등)             |
| **프로세스 ID (PID)**   | 고유 식별자 (Process ID)                           |
| **Program Counter** | 다음에 실행할 명령어의 주소                               |
| **CPU 레지스터**        | 연산 중이던 레지스터 값들 (R1, R2, PC, SP 등), 문맥 교환 시 저장 |
| **메모리 정보**          | 코드, 데이터, 스택 영역 주소, 페이지 테이블, 세그먼트 테이블 등        |
| **파일 정보**           | 열린 파일 핸들, 파일 디스크립터 테이블 등             |
| **스케줄링 정보**         | 우선순위, 스케줄링 큐 포인터, CPU 점유 시간 등      |
| **계정 정보**           | 사용자 ID, 그룹 ID, 권한 정보 등                 |
| **입출력 상태**          | 사용 중인 I/O 장치, 대기 중인 I/O 요청 정보 등      |


## 7. 프로세스들끼리 메모리 영역 구조가 같은 이유
- 운영체제 설계의 표준화
    - 대부분 운영체제(OS)는 프로세스를 효율적으로 관리하기 위해 일관된 메모리 구조 모델 사용
    - CPU, 메모리 관리장치(MMU), 가상 메모리 시스템, 스케줄러 등 시스템 구성 요소들이 프로세스를 공통된 방식으로 다룰 수 있음.
- 프로그램 실행 방식의 공통성
    - 프로그램 실행은 기본적으로 코드 실행 → 데이터 사용 → 동적 메모리 할당 → 함수 호출과 반환 과정을 거침
    - 이 흐름에 맞춰 메모리를 나누면 구조가 자연스럽게 코드/데이터/힙/스택 으로 나뉨

- 가상 메모리 관리와 보호를 위한 논리적 분할
    - 각 영역별로 접근 권한(읽기, 쓰기, 실행)을 다르게 주고, 메모리 충돌이나 오염을 막기 위해 영역을 분리함
    - 이런 분리는 OS가 안정성과 보안을 유지하는 데 필수적
- 컴파일러와 링커의 역할
    - 컴파일러는 코드, 전역 변수, 정적 변수, 초기화되지 않은 변수 등을 각각 다른 세그먼트에 배치함.
 

