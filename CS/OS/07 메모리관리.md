## 1. 메모리관리

### 1. 메모리 관리자
- 역할: 프로세스에 메모리를 할당, 해제하고 보호하는 운영체제 내 모듈
- 협업 대상: 운영체제의 메모리 관리 모듈 + 하드웨어(메모리 관리 장치, MMU)
- 주요 정책
    - 적재 정책 (Loading Policy): 디스크에서 메모리로 프로세스를 언제 반입할지 결정
    - 배치 정책 (Placement Policy): 메모리 내 어떤 위치에 프로세스를 적재할지 결정
    - 대치 정책 (Replacement Policy): 메모리가 부족할 때 어떤 프로세스를 제거할지 결정

### 2. 메모리구조와 매핑
- 논리 주소 (Logical Address): 프로그래머가 사용하는 가상의 주소 공간
- 물리 주소 (Physical Address): 실제 메모리 칩 내 주소 공간
- 바인딩 (Binding): 논리 주소를 물리 주소로 변환하는 작업
    - 컴파일 시간 바인딩: 컴파일 시점에 모든 주소 결정, 실행 중 변경 불가
    - 적재 시간 바인딩: 컴파일 시 상대 주소만 남기고, 적재 시점에 물리 주소로 결정
    - 실행 시간 바인딩: 실행 중에 주소 변환 (주로 MMU가 수행)

### 3. 메모리 관리 기법
- 동적 적재 (Dynamic Loading)
    - 프로세스 전체가 아니라, 필요한 코드/데이터만 실행 시점에 메모리에 적재
    - 메모리 사용 효율 증대, 실행 속도 개선 가능

- 중첩 (오버레이, Overlay)
    - 공통 영역은 항상 메모리에 유지
    - 필수적이지 않은 영역들은 한정된 메모리 공간에 덮어 씌우면서 번갈아 적재
    - 메모리가 극히 제한된 환경에서 사용

- 스와핑 (Swapping)
    - 프로세스 전체 단위로 메모리와 보조기억장치(디스크) 사이를 이동
    - 메모리가 부족할 때 비활성 프로세스를 디스크로 내리고, 필요한 프로세스를 메모리에 올림

- 연속 메모리 할당 (Contiguous Allocation)
    - 프로세스에 필요한 메모리를 하나의 연속된 블록으로 할당
    - 단순하고 빠르지만, 외부 단편화 문제가 발생할 수 있음

- 분산 메모리 할당 (Non-contiguous Allocation)
    - 프로세스 메모리를 여러 개의 분리된 블록으로 나누어 할당
    - 외부 단편화 문제를 줄이고 유연성 높음, 주소 변환이 필요함

## 2. 연속 메모리 할당 🔖
| 구분             | 단일 프로그래밍 환경 | 다중 프로그래밍 환경                |
| -------------- | --------------------------- | -------------------------- |
| **개념**         | 하나의 프로세스만 메모리를 독점 사용        | 여러 프로세스가 메모리를 나누어 연속 공간 할당 |
| **메모리 할당 방식**  | 프로세스 전체를 연속된 메모리 공간에 할당     | 각 프로세스에 연속된 메모리 블록을 할당     |
| **장점**         | 구조 단순, 관리 용이, 빠른 메모리 접근     | CPU 및 자원 활용 효율 증대          |
| **단점**         | 메모리 활용률 낮음, 다중 프로그래밍 불가     | 외부 단편화 문제, 관리 복잡도 증가       |
| **단편화 문제**     | 거의 없음                       | 외부 단편화 발생 가능               |
| **운영체제 적용 예시** | 초기 단일 작업 시스템 (예: 초기 MS-DOS) | 초기 다중 프로그래밍 시스템            |
| **관리 필요성**     | 낮음| 높음 (메모리 할당/해제 빈번)          |

## 3. 분산메모리할당 🔖
### 1. 페이징
- 프로세스를 고정 크기의 페이지 단위로 나누고, 물리 메모리를 동일한 크기의 프레임(Frame)으로 나눈 뒤, 각 페이지를 아무 위치의 프레임에 적재하는 방식.

| 항목       | 내용                                                      |
| -------- | ------------------------------------------------------- |
| 단위     | 페이지 (Page), 프레임 (Frame) – 크기 고정|
| 메모리 위치 | 연속되지 않아도 됨 (분산되어 있음)|
| 테이블    | 페이지 테이블 (Page Table)로 논리주소 → 물리주소 매핑|
| 장점     | 외부 단편화 없음, 메모리 활용도 높음|
| 단점     | 내부 단편화 존재 가능 (페이지보다 작은 단위는 못 채움), 주소변환에 오버헤드|
| 예시       | 프로세스가 10KB고 페이지가 4KB면 → 3페이지로 나눔 → 메모리에서 3개의 아무 프레임에 배치 |

### 2. 세그먼테이션
- 프로세스를 의미 있는 논리 단위(세그먼트로 나누고, 각 세그먼트를 메모리의 아무 위치에 적재하는 방식. (함수, 배열, 스택 등 구조에 따라 나눔)

| 항목  | 내용                                       |
| --- | ---------------------------------------- |
| 단위  | 세그먼트 (Segment) – 크기 가변                   |
| 메모리 위치 | 연속되지 않아도 됨 (분산됨)                         |
| 테이블 | 세그먼트 테이블 (Segment Table)로 논리주소 → 물리주소 매핑 |
| 장점  | 구조적으로 의미 있는 분할, 모듈화 쉬움                   |
|  단점 | 외부 단편화 발생 가능 (가변 크기), 주소 계산 복잡           |
| 예시  | 코드 영역, 데이터 영역, 스택을 각각 다른 위치에 적재          |

### 3. 페이징과 세그먼테이션
| 구분    | 페이징 (Paging) | 세그먼테이션 (Segmentation) |
| ----- | ------------ | --------------------- |
| 분할 단위 | 고정 크기 페이지    | 가변 크기 세그먼트            |
| 단편화   | 내부 단편화       | 외부 단편화                |
| 테이블   | 페이지 테이블      | 세그먼트 테이블              |
| 주소 구성 | 페이지 번호 + 오프셋 | 세그먼트 번호 + 오프셋         |
| 장점    | 메모리 활용도 좋음   | 논리적 구조 반영 가능          |
| 단점    | 논리구조 무시      | 외부 단편화 발생 가능          |
