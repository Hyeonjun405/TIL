
> 운영체제에서 파일 시스템이란, 디스크 같은 저장 장치에 파일과 디렉터리 구조를 구성하여 데이터를 효율적으로 저장하고 관리하는 체계이다. 사용자는 이러한 논리적 구조를 통해 파일에 접근하며, 내부적으로는 각 파일마다 고유하게 존재하는 i노드(inode)에 저장된 메타데이터(metadata)를 기반으로, 운영체제가 물리적인 저장 장치에서 실제 파일 데이터를 찾고, 다양한 파일 조작 작업을 수행할 수 있도록 함.

## 01. 파일

### 1. 파일시스템
- 파일 시스템은 운영체제가 디스크 같은 보조 저장 장치에 데이터를 저장, 관리, 접근할 수 있도록 정의한 논리적 구조와 알고리즘의 집합이다.
- 파일은 보조 저장 장치(디스크)에 저장된 이름과 정보의 묶음으로, 프로그램 실행파일 또는 사용자 데이터를 저장하는 단위이다.
- 데이터는 사용자가 관심 있는 파일의 내용(payload)을 의미

### 2. 파일시스템의 기능
| 기능          | 설명                                            |
| ----------- | --------------------------------------------- |
| 파일 구성       | 사용자가 업무에 적합한 구조로 파일을 구성할 수 있게 지원 (예: 디렉터리 트리) |
| 파일 관리       | 파일의 생성, 수정, 저장, 참조, 제거, 보호 등 기본적인 조작을 지원      |
| 보조 기억 장치 관리 | 디스크 등의 저장장치에 파일을 저장할 공간을 할당하고 입출력을 제어         |
| 파일 무결성 보장   | 시스템 오류나 전원 장애로부터 데이터를 보호하고, 손상 방지 (예: 저널링)    |
| 파일 접근 방법 제공 | 순차 접근, 직접 접근 등 다양한 방식의 접근 제어를 제공              |
| 장치 독립성 유지   | 파일명을 통해 장치의 물리 위치와 무관하게 접근 가능 (논리적 추상화)       |
| 파일 백업과 복구   | 정보 손실을 대비한 백업/복구 기능 제공                        |
| 파일 보호       | 접근 권한, 암호화 등을 통해 불법 접근이나 정보 노출 방지             |
| 정보 전송       | 사용자 요청에 따라 파일 간 정보 복사 및 이동 기능 제공              |



### 3. 파일 시스템 계층 구조 (File System Architecture)
| 계층명| 역할| 예시 및 키워드                               |
| ---- | --------------------------------- | -------------------------------------- |
| 응용 프로그램| 사용자가 직접 사용하는 소프트웨어| 텍스트 에디터, 브라우저, IDE|
| 논리 파일 시스템| 사용자 관점의 파일 관리 (경로, 권한 등), 시스템콜 처리 | `open()`, `read()`, `ls`, 경로 파싱, 접근 제어 |
| 파일 구성 모듈| 파일의 논리 구조를 저장장치 블록으로 매핑| 파일 → inode → 블록 매핑, 디렉터리 관리|
| 기본 파일 시스템| 블록 단위 읽기/쓰기 처리, 버퍼 캐시 운영| `read_block()`, `write_block()`|
| 입출력 제어기 (I/O Control) | 장치 드라이버 호출 및 제어 블록 준비| 인터럽트 처리, DMA 제어|
| 장치 드라이버| 실제 하드웨어를 제어하는 코드| SATA 드라이버, SSD 펌웨어 호출 등|
| 저장장치 (Device)| 물리적인 디스크| HDD, SSD, USB 등|


### 4. 파일 시스템 관리 기준
- 블록 (Block)
    - 디스크는 보통 고정 크기의 블록 단위로 나뉘며 (예: 512B, 4KB), 파일은 이 블록 단위로 저장함.
    - 파일이 저장될 때는 여러 개의 블록에 나뉘어 저장되며, 운영체제는 어떤 블록이 어떤 파일에 속하는지 추적함.
    - 블록 할당 방식 (연속, 연결, 인덱스 등), 버퍼 캐시, 프리 블록 리스트 등

- 메타데이터 (Metadata)
    - 메타데이터는 파일 시스템의 논리적 구성을 이루는 핵심.
    - 파일 그 자체가 아니라, 파일에 대한 정보를 지칭함.
    - 이름, 생성일, 마지막 수정일, 파일 크기, 퍼미션, 소유자 ID, inode 번호 등

- 마운팅 (Mounting)
    - 하나의 운영체제 안에 여러 파일 시스템(ext4, NTFS 등)을 사용할 수 있기 때문에, 이를 하나의 계층적 트리에 연결하는 과정이 필요함.
    - mount, umount 명령으로 제어
    - USB를 꽂았을 때 /mnt/usb에 자동 연결되는 것도 일종의 마운트


### 5. 파일의 개념과 구성
| 용어              | 설명                      | 예시                            |
| --------------- | ----------------------- | ----------------------------- |
| 파일(File)    | 디스크에 저장된 데이터의 논리 단위     | `students.csv`, `report.docx` |
| 블록(Block)   | 디스크의 최소 입출력 단위 (보통 4KB) | 디스크 I/O는 블록 단위로 수행|
| 레코드(Record) | 파일 안의 데이터 한 줄 또는 한 항목   | 한 학생의 정보 한 줄|
| 필드(Field)   | 레코드 안의 세부 항목            | 이름, 나이, 학번 등|

### 6. 파일유형
| 유형          | 설명                 | 예시                        | 리눅스 명령어로 확인 (`ls -l`)      |
| ----------- | ------------------ | ------------------------- | -------------------------- |
| 일반 파일   | 데이터가 저장된 일반적인 파일   | `.txt`, `.jpg`, `.c` 등    | `-rw-r--r--` → `-`로 시작     |
| 디렉터리 파일 | 다른 파일들을 담는 폴더      | `/etc`, `/home`, `/usr` 등 | `drwxr-xr-x` → `d`로 시작     |
| 특수 파일   | 장치와 입출력용으로 사용하는 파일 | `/dev/sda`, `/dev/null` 등 | `brw-rw----`, `crw-rw----` |

### 7. 파일 디스크립터
| 계층      | 설명                                         |
| ------- | ------------------------------------------ |
| 사용자 관점  | 파일을 열면 정수형 ID(예: 3)를 반환받음. 이것이 바로 파일 디스크립터 |
| 프로세스 관점 | 각 프로세스는 자신만의 파일 디스크립터 테이블을 가지고 있음          |
| 커널 관점   | 디스크 파일에 대한 실제 정보(inode, 위치, 모드 등)는 커널이 관리함 |


### 8. 파일에 엑세스하는 방법
| 방식명| 설명                         | 사용 예시                   |
| ------------------------------- | ---------- | ----------------------- |
| 순차 액세스(Sequential Access)| 처음부터 차례로 읽기/쓰기| 텍스트 파일, 로그파일            |
| 직접 액세스(Direct / Random Access) | 임의의 위치로 점프해서 읽기/쓰기| DB파일, 바이너리 파일|
| 인덱스 순차 액세스  (Indexed Sequential Access) | 인덱스로 위치를 찾아서, 이후 순차 접근 | 대용량 레코드 파일, B+트리 기반 시스템 |


## 02. 디렉토리
### 1. 디렉터리
- 디렉터리는 파일 시스템에서 파일(또는 다른 디렉터리)의 이름과 그에 해당하는 메타정보(i-node 번호 등)를 저장한 특수한 파일
- 역할

| 역할                 | 설명                                           |
| ------------------ | -------------------------------------------- |
| 파일 이름과 inode 번호 매핑 | 사용자 친화적 이름을 시스템 내부 번호와 연결                    |
| 파일 조직              | 관련 파일들을 묶어 관리 (예: 이미지, 문서 따로)                |
| 경로 관리              | 트리 구조를 통해 파일 경로 표현                           |
| 디렉터리 안에 디렉터리       | 디렉터리는 다른 디렉터리를 포함할 수 있어 → **계층적 구조 (트리)** 생성 |

### 02 디렉터리 구현
- 선형 리스트 (Linear List)
    - 특징
        - 디렉터리 내의 파일 엔트리를 순서대로 나열한 리스트 구조
        - 각 엔트리는 파일 이름과 inode 번호 등 메타데이터를 담고 있음.
    - 동작 방식
        - 파일 이름을 찾을 때 리스트를 처음부터 끝까지 순차 탐색(선형 탐색)함.
        - 삽입, 삭제는 리스트 내 위치에 따라 다르지만 보통 간단함.
- 해시 테이블 (Hash Table)
    - 특징
        - 파일 이름을 해시 함수에 입력해 해시 값에 대응하는 버킷(bucket)에 파일 엔트리를 저장하는 구조.
        - 빠른 검색을 위해 설계됨.
    - 동작 방식
        - 파일 이름으로 해시 함수를 계산해 저장 위치 결정.
        - 해시 충돌이 나면 체이닝이나 오픈 어드레싱 기법으로 해결.

### 03 디렉터리구조
| 구조 종류    | 특징                | 장점            | 단점               |
| -------- | ----------------- | ------------- | ---------------- |
| 1단계 디렉터리 | 단일 디렉터리에 모든 파일 존재 | 단순함           | 확장성 낮음, 이름 충돌 가능 |
| 2단계 디렉터리 | 사용자별 디렉터리 존재      | 사용자별 이름 충돌 해결 | 사용자간 협업 어려움      |
| 트리 구조(주로사용)| 다중 수준 계층적 조직      | 조직적, 확장성 좋음   | 경로 탐색 복잡         |
| 비순환 그래프  | 하드 링크 허용, 순환 없음   | 중복 없이 공유 가능   | 관리 복잡            |
| 일반 그래프   | 심볼릭 링크 포함, 순환 가능  | 유연성 극대화       | 무한 루프 위험         |
- 하드 링크는 한 파일을 여러 디렉터리에서 가리킬 수 있게 하는 기능으로, 이런 연결 때문에 트리가 살짝 변형되어 순환은 없지만 하나의 파일이 여러 부모를 가질 수 있는 비순환 그래프 형태가 됨
- 심볼릭 링크(Symbolic Link, Soft Link) 같은 기능이 포함된 경우인데, 심볼릭 링크는 실제 파일이 아닌 파일 위치를 가리키는 별도의 파일


## 03. 파일할당
### 1. 파일의 디스크 할당
- 연속 할당 (Contiguous Allocation)
    - 파일의 모든 데이터를 디스크에 연속된 블록에 저장
    - 장점: 읽고 쓰기 빠름 (연속이니까 디스크 헤드 이동 적음)
    - 단점: 큰 파일을 위해 연속된 공간을 찾기 어렵고, 파일 크기 변경 어려움
- 연결 할당 (Linked Allocation)
    - 파일의 각 블록이 포인터로 다음 블록을 가리키는 방식
    - 장점: 조각난 빈 공간에도 저장 가능
    - 단점: 임의 접근(random access) 느림 (하나씩 따라가야 하니까)
- 인덱스 할당 (Indexed Allocation)
    - 별도의 인덱스 블록 하나가 여러 데이터 블록의 주소를 저장
    - 장점: 임의 접근이 빠름 (인덱스를 통해 바로 위치 파악 가능)
    - 단점: 인덱스 블록의 크기에 따라 관리 오버헤드 존재

### 2. 디스크 할당 방법
| 방법| 설명| 장점               | 단점|
| --------- | ------------------ | ---------------- | --------------------- |
| 비트맵 (Bitmap)                | 디스크 각 블록 상태를 1비트로 표시<br>1=사용 중, 0=빈 공간    | 빈 공간 찾기 쉽고 빠름    | 디스크가 커질수록 비트맵 크기 증가, 관리 비용 증가 |
| 연결리스트 (Linked List)         | 빈 블록들을 포인터로 연결해 관리<br>각 블록에 다음 빈 블록 주소 포함 | 메모리 절약, 동적 관리 가능 | 빈 공간 탐색 시 연결 따라가야 해서 느릴 수 있음  |
| 인덱스 블록 (Indexed Block, 그룹핑) | 빈 공간 블록 주소를 별도 인덱스 블록에 모아 관리 | 체계적이고 빠른 접근 가능   | 인덱스 블록 관리에 추가 공간과 복잡성 필요      |

### 3. 파일보호
| 보호 방법  | 설명                    |
| ------ | --------------------- |
| 파일 명명  | 이름 규칙으로 접근 제한 및 혼동 방지 |
| 암호     | 파일 내용을 암호화해 무단 접근 방지  |
| 액세스 제어 | 사용자별 읽기/쓰기/실행 권한 설정   |
| 액세스 그룹 | 사용자 그룹 단위로 권한 관리      |
| 사용자 권한 | 개별 사용자별로 세밀한 접근 권한 부여 |