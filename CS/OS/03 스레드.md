
## 1. 스레드
- 스레드(Trhead)는 프로세스에서 작업을 실행하는 단위
- 스레드 한개가 들어가면 단일 스레드(SingleThread), 다수의 스레드가 들어가면 다중 스레드(Multi Thread)
- 다중 스레드(MUlti Thread)는 다수의 실행을 병렬로 진행할 수 있음.

## 2. 경량 프로세스 / 중량 프로세스
### 1. 경량 프로세스 (Lightweight Process)
- 일반적인 의미의 스레드(Thread)
- 프로세스의 주소 공간, 코드 영역, 데이터, 힙 등을 다른 스레드와 공유
- 단지 Program Counter, 스택, 레지스터 집합만 독립적으로 가짐
- 문맥 전환 비용이 매우 낮음
### 2. 중량 프로세스 (Heavyweight Process)
- 일반적인 의미의 프로세스(Process
- 완전히 독립적인 주소 공간과 시스템 자원을 가지며, 다른 프로세스와는 자원을 공유하지 않음
- 문맥 전환 비용이 높음

## 3. 스레드 제어 블록
- Thread Control Block
- 프로세스가 프로세서 제어블록(PCB)에 정보를 저장하듯이 스레드도 스레드 제어블록(TCB)에 정보를 저장한다.
- 스레드 제어 블록 내용

| 정보 항목               | 설명                              |
| ------------------- | ------------------------------- |
| **스레드 ID (TID)**    | 스레드를 식별하는 고유 번호                 |
| **스레드 상태**          | Running, Ready, Waiting 등 현재 상태 |
| **프로그램 카운터(PC)**    | 다음에 실행할 명령어 주소                  |
| **CPU 레지스터 상태**     | 각종 레지스터 값 (예: 스택 포인터, 일반 레지스터)  |
| **스택 포인터**          | 스레드의 스택 위치                      |
| **우선순위**            | 스케줄링 시 우선순위 정보                  |
| **스레드의 스택 메모리 정보**  | 스택 크기 및 위치                      |
| **스레드가 속한 프로세스 정보** | 소속 프로세스 ID(PID) 등               |
| **스케줄링 정보**         | 스케줄러에 필요한 기타 정보 (예: 시간 할당량)     |
| **동기화 관련 정보**       | 뮤텍스, 세마포어 등 동기화 객체 상태           |

## 4. 스레드 구현
### 1. 사용자 수준 스레드
- 구현
    - 사용자의 영역의 스레드 라이브러리로 구현
    - 커널은 스레드가 아닌 프로세스 한 단위로 인식하고 프로세서를 할당
- 장점
    - 커널에 독립적으로 스케줄링을 할 수 있어 모든 운영체제 적용 가능함.
    - 스케줄링이나 동기화를 하기위해 커널을 호출하지 않아 커널로 전환하는 오버헤드가 적음
    - 스레드 라이브러리에서 스케줄링을 하므로 유연한 스케줄링이 가능함.
- 단점
    - 스레드가 아닌 프로세스 단위로 프로세서를 할당하여 다중처리 환경을 구성해도 스레드 단위 다중처리가 불가함.
    - 커널이 한 프로세스에 속한 여러 스레드에 프로세서를 동시에 할당 할 수 없음
    - 스레드 간 보호에 커널의 보호 방법을 사용 불가함.

### 2. 커널 수준 스레드
- 구현
    - 커널에서 직접 스레드를 생성하고 관리함.
    - 커널이 스레드를 독립적인 실행 단위로 인식하여, 각 스레드에 직접적으로 프로세서를 할당함.
- 장점
    - 스레드 단위로 커널이 직접 스케줄링하여, 진정한 병렬 처리(multi-core) 가능.
    - 하나의 스레드가 블로킹되더라도 커널이 다른 스레드를 실행 가능.
    - 커널의 보호 기법(예: 우선순위, 선점 등)을 활용 가능하여 안정성 확보.

- 단점
    - 사용자에서 커널로 전환되는 오버헤드(Context Switching Overhead)가 발생.
    - 모든 스레드 연산 시 커널의 개입이 필요하므로 처리 비용이 큼.
    - 스레드 관리를 위해 커널이 복잡한 구조와 자원 사용을 요구함.

### 3. 혼합형 스레드
- 구현
    - 사용자 수준 스레드와 커널 수준 스레드의 장점을 결합한 구조.
    - 사용자 수준에서 여러 스레드를 생성하고, 이들을 소수의 커널 스레드에 매핑하여 실행 (예: N: M 모델).

- 장점
    - 사용자 수준의 빠른 스케줄링과 커널 수준의 병렬 실행을 동시에 구현 가능.
    - 일부 사용자 스레드가 블로킹되더라도, 다른 커널 스레드를 통해 실행 지속 가능.
    - 운영체제의 효율성과 유연성 모두 확보 가능.

- 단점
    - 사용자 스레드와 커널 스레드 간의 매핑, 관리 복잡도가 증가함.
    - 사용자 수준 스케줄러와 커널 수준 스케줄러 간 충돌 가능성 존재.
    - 잘못된 매핑이나 자원 분배 시 성능 저하나 동기화 이슈가 발생할 수 있음.
- 예시
    - 사용자 수준 스레드 A, B는 각각 다수의 경량 프로세스(LWP) 중 하나에 동적으로 매핑될 수 있으며,
    - 만약 A가 매핑된 LWP(A1)가 블로킹(blocking) 되었다면,
    - B는 다른 LWP(B1)에 재매핑되어 실행될 수 있으므로,
    - 결과적으로 자원 활용률이 향상되고 병목이 줄어드는 구조


## 5. 다중스레드 vs 다중프로세스
### 1.  "다중 스레드(Multithreading)"와 "다중 프로세스(Multiprocessing)"는 병렬성과 동시성 처리를 위한 개념
    - 다중 스레드는 하나의 프로세스 내부에서 여러 스레드가 메모리를 공유하며 동시에 실행됨
    - 다중 프로세스는 여러 개의 독립된 프로세스가 메모리/자원 분리 상태로 각각 실행됨
### 2. 병렬성과 동시성

| 구분                    | 의미                              | 예시                      |
| --------------------- | ------------------------------- | ----------------------- |
| **병렬성 (Parallelism)** | **물리적으로 동시에 실행**                | 2개의 CPU가 각각 다른 작업 수행    |
| **동시성 (Concurrency)** | **논리적으로 동시에 실행 (순차적으로 쪼개어 실행)** | 1개의 CPU가 빠르게 작업을 번갈아 수행 |

### 3. 비교

| 항목   | 다중 프로세스 (Multiprocessing)  | 다중 스레드 (Multithreading) |
| ------------------ | --------------- | --------------------------------- |
| **단위**             | 프로세스 (Process)                 | 스레드 (Thread)     |
| **메모리**            | **독립된 주소 공간** (heap, stack 분리) | **공유된 주소 공간** (heap 공유, stack 분리) |
| **통신 방식**          | IPC (파이프, 소켓, 메시지큐 등) 필요    | 공유 변수, 동기화 객체 등 직접 접근 가능          |
| **컨텍스트 전환 비용**     | **크다 (커널 수준)**      | **작다 (경량)**  |
| **안정성 (crash 격리)** | 하나 죽어도 다른 프로세스 영향 없음      | 하나 죽으면 전체 프로세스 위험 가능              |
| **디버깅/관리**         | 상대적으로 단순          | 동기화 이슈, 디버깅 어려움   |
| **스케줄링 단위**    | OS 스케줄러가 관리    | OS 스케줄러 + 사용자 쓰레드 가능 |
| **사용 예시**   | Chrome 탭, DB 서버 프로세스, 백그라운드 데몬 | 게임 루프, 웹 서버 쓰레드 풀, 병렬 계산   |

※ **다중 스레드(multithreading)**는 코드 영역, 데이터 영역(힙)을 공유하므로 메모리 사용량이 적고,
**다중 프로세스(multiprocessing)**는 각자 독립된 메모리 공간을 가지므로 메모리 사용량이 많음.
