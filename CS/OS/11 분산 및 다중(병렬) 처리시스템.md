## 01. 분산시스템
### 1. 분산시스템/네트워크
- 분산처리는 여러 컴퓨터 사용자들이 네트워크로 연결되어 서로 데이터를 주고받으며 협력해서 작업을 수행하는 시스템
- 네트워크는 서로 독립된 시스템들이 빠른 통신 채널을 통해 상호 통신할 수 있도록 지원하는 데이터 통신 구조

### 2. 시스템 구성
- 약결합 (Loosely Coupled) 시스템
    - 독립적인 시스템 여러 대를 통신선으로 연결
    - 각 시스템은 자체 메모리와 운영체제를 가지고 독립적 운영
    - 예: 분산시스템, 클러스터

- 강결합 (Tightly Coupled) 시스템
    - 여러 프로세서가 메모리를 공유하는 다중처리 시스템
    - 하나의 운영체제 아래에서 협력 수행
    - 예: SMP(Symmetric Multiprocessing) 시스템 => 멀티프로세서

### 3. 네트워크 구조
| 구조 형태 | 설명                         | 예시                   |
| ----- | -------------------------- | -------------------- |
| 망 구조  | 모든 노드가 서로 직접 연결됨           | 군사 통신망, 고신뢰성 금융망 등   |
| 트리 구조 | 계층적 구조, 루트 노드에서 분기         | 기업의 조직망, DNS 구조 등    |
| 성형 구조 | 중앙 허브를 중심으로 모든 노드가 연결      | 이더넷 LAN (허브 기반)      |
| 링 구조  | 노드들이 고리처럼 연결되어 데이터가 순환     | FDDI, 토큰 링 네트워크      |
| 버스 구조 | 하나의 통신선(버스)에 모든 노드가 공유 연결됨 | 초기 이더넷, CAN 통신 (자동차) |

### 4. 원격프로시저
| 항목               | 설명|
| ---------------- | ----------------- |
| 원격 프로시저          | 컴퓨터에서 실행하는 프로세스를 다른 컴퓨터에서 실행하는 프로세스의 프로시저(함수)가 호출할 수 있게 하는 것|
| 스터브(Stub)| 전송 데이터를 준비(마샬링)하고, 수신 데이터를 변환(언마샬링)해서 올바르게 해석할 수 있도록 지원하는 모듈|
| 마샬링(Marshalling) | 데이터를 네트워크 전송용 형식으로 변환하는 과정 (직렬화)|
- 원격 호출 과정
    1) 클라이언트가 함수 호출 → 2) 클라이언트 스터브가 마샬링 → 3) 네트워크 전송
       → 4) 서버 스터브가 언마샬링 → 5) 서버 함수 실행 → 6) 서버 스터브가 결과 마샬링 → 7) 네트워크 응답
       → 8) 클라이언트 스터브가 결과 언마샬링 → 9) 클라이언트에 결과 전달

### 5. 분산시스템의 목적
| 목적        | 설명                                                              |
| --------- | --------------------------------------------------------------- |
| 자원 공유| 여러 컴퓨터의 하드웨어, 소프트웨어, 데이터 등을 공유하여 효율성 극대화|
| 병렬 처리     | 작업을 여러 노드에 분산시켜 동시에 처리함으로써 처리 속도 향상|
| 신뢰성 향상    | 일부 노드 고장 시에도 전체 시스템이 계속 작동하도록 내결함성 확보|
| 확장성       | 노드를 추가해 시스템 처리 능력과 저장 용량을 쉽게 확장 가능|
| 투명성       | 사용자나 애플리케이션이 분산된 여러 컴퓨터를 하나의 시스템처럼 인식하도록 지원 (위치, 접근, 동시성 투명성 등) |
| 유연성 및 확장성 | 다양한 환경과 요구에 맞게 시스템 변경 및 확장 가능|

## 02.네트워크 운영체제 / 분산 운영체제
| 구분              | 설명                                | 특징 및 역할                    | 예시                             |
| --------------- | --------------------------------- | -------------------------- | ------------------------------ |
| 네트워크 운영체제       | 여러 컴퓨터가 네트워크로 연결되어 자원 공유를 지원하는 OS | 각 컴퓨터가 독립적으로 운영, 자원 공유 중심  | Windows Server, Novell NetWare |
| 분산 운영체제         | 여러 컴퓨터를 하나의 통합된 시스템처럼 관리하는 OS     | 자원과 작업을 통합 관리, 투명성 제공      | Amoeba, Mach, Plan 9           |


## 03. 네트워크 운영체제
### 1. 네트워크 운영체제
- 여러 대의 컴퓨터를 네트워크로 연결해 자원(파일, 프린터, 사용자 계정 등)을 공유하고 관리할 수 있게 해주는 운영체제
- 윈도우 서버(Windows Server) / 노벨 넷웨어(Novell NetWare) / 유닉스/리눅스 기반 서버 OS / Mac OS 서버(Mac OS X Server)

### 2. 주요기능
| 주요 기능    | 설명                                              |
| -------- | ----------------------------------------------- |
| 자원 공유    | 네트워크 상에서 파일, 프린터, 저장장치 등 자원을 여러 사용자가 공동으로 사용 가능 |
| 접근 권한 부여 | 사용자 인증 및 권한 관리를 통해 네트워크 자원에 대한 접근 통제            |
| 파일 전송    | 네트워크를 통해 파일을 안전하고 효율적으로 전송하는 기능 제공              |
| 데이터 보호   | 데이터 암호화, 백업, 무결성 검사 등 보안 기능 지원                  |
| 관리 및 제어  | 네트워크 구성, 사용자 계정, 보안 정책, 자원 할당 등을 중앙에서 관리 및 모니터링 |

### 3. 운용 방법
- 피투피(Peer To Peer)모델
    - 특징
        - 네트워크에 참여하는 모든 노드(피어)가 동등한 권한을 가지고 서로 자원을 직접 공유
        - 중앙 서버 없이 각 노드가 클라이언트이자 서버 역할을 동시에 수행
        - 분산된 구조로 장애에 강하고 확장성이 좋음
    - 장점
        - 중앙 서버 부하 없음
        - 노드 추가/삭제가 자유로워 유연함
        - 비용 절감 가능
    - 단점
        - 보안 관리가 어려움
        - 자원 검색 및 관리가 복잡할 수 있음
    - 파일 공유 / 분산 저장소 / 블록체인 및 암호화폐 / 실시간 통신

- 클라이언트/서버 모델
    - 특징
        - 네트워크에서 서버는 자원을 제공하고 클라이언트는 요청하는 역할로 명확히 구분
        - 서버는 중앙 집중식으로 자원을 관리
        - 클라이언트는 사용자 인터페이스 및 요청 전달 담당
    - 장점
        - 중앙 집중식 관리로 보안과 자원 관리 용이
        - 역할 분담으로 시스템 구조가 명확
        - 유지보수 및 확장 용이
    - 단점
        - 서버에 장애가 발생하면 서비스 전체에 영향
        - 서버 부하 집중 가능

## 04. 분산 운영체제
### 1. 분산운영체제
- 물리적으로 분리된 다수의 컴퓨터 시스템(노드)을 네트워크로 연결하여, 사용자에게는 하나의 통합된 시스템처럼 보이도록 자원과 작업을 통합 관리하는 운영체제.
- 특징
    - 투명성 (Transparency): 위치 투명성, 접근 투명성, 복제 투명성, 병행성 투명성 등.
    - 확장성 (Scalability): 노드 수가 증가해도 시스템이 성능을 유지함.
    - 고가용성 (High Availability): 장애 발생 시에도 서비스 지속 가능.
- 제어 요소
- 데이터 이동 (Data Migration): 자원 근처로 데이터를 옮겨 I/O 병목을 줄임.
- 연산 이동 (Computation Migration): 데이터가 위치한 노드로 연산을 이동시켜 네트워크 부하 최소화.
- 프로세스 이동 (Process Migration): 부하 균형, 자원 접근 최적화를 위해 프로세스 자체를 다른 노드로 이동.
- 소프트웨어 이익 (Software Advantages): 자원 공유 최적화 / 작업 병렬화 / 시스템 신뢰도 증가

### 2. 분산 운영체제의 구현
- 프로세스 기반 (Process-based)
    - 분산 노드 간에 독립적인 프로세스를 생성하고 통신 및 동기화 기법을 통해 상호작용.
    - 예시: Amoeba, Mach
- 객체 기반 (Object-based)
    - 각 노드를 객체로 추상화하고, 분산 객체 간의 원격 메서드 호출(RMI)을 통해 기능 수행.
    - 객체 식별자, 위치 투명성을 위한 미들웨어 필요 (예: CORBA, Java RMI)
    - 모듈화가 용이하고 유지보수성 우수

### 3. 분산 시스템에서프로세스 관리
- 자원 할당 교착 상태 (Resource Allocation Deadlock)
    - 분산 환경에서 자원을 둘 이상의 노드가 공유할 때 교착상태(Deadlock) 발생 가능성 존재.
    - 예방 (Prevention)
        - 자원 요청 순서를 정하고 위반하지 않도록 설계.
        - 예: 은행원 알고리즘처럼 자원 할당 시점에서 미리 조건 점검.
    - 탐지 (Detection)
        - Wait-for Graph 또는 Probe 알고리즘 등을 사용해 주기적으로 탐지.
        - 노드 간 정보를 주고받으며 탐지 수행.
    - 회피 (Avoidance)
        - 시스템이 안전 상태(Safe State)를 유지할 수 있는 자원 할당만 허용.
        - 실시간 자원 상태 및 요청 추적 필요.
    - 복구 (Recovery)
        - 교착 상태 발견 시 프로세스 종료 또는 자원 강제 회수(Preemption).
        - 비용이 크므로 마지막 수단으로 사용.

- 메시지 전송 교착상태
    - 메시지 기반 통신에서 프로세스 간의 상호대기 또는 버퍼 고갈로 인해 교착 상태가 발생할 수 있음.
    - 상호대기 (Mutual Wait)
        - A가 B의 메시지를 기다리고, B도 A의 메시지를 기다릴 경우.
    - 메시지 할당 버퍼 불충분 (Insufficient Message Buffers):
        - 송신자가 비동기 메시지를 보내려는데, 수신 측에서 수신 버퍼가 꽉 찬 경우.
        - 해결책: 무한 버퍼는 현실적으로 불가능 → 제한 버퍼 모델 + Flow Control 필요.
          메시지 우선순위 및 큐 관리 필요.

## 05. 클라이언트/서버분산 컴퓨팅
### 1. 클라이언트/서버분산 컴퓨팅
- 클라이언트/서버 모델은 분산 컴퓨팅 환경에서 서비스 제공자(서버)와 서비스 요청자(클라이언트) 가 명확하게 역할을 나누는 구조.
- 클라이언트는 사용자 인터페이스(UI)와 일부 로직을 담당하고, 서버는 데이터 처리 및 저장, 핵심 비즈니스 로직 수행.
- 네트워크를 통해 양자는 메시지를 주고받으며 동작.

### 2. 2계층 클라이언트/서버 구조 (Two-Tier Architecture)
- 팻 클라이언트 (Fat Client)
    - 클라이언트 측에서 UI + 일부 애플리케이션 로직 + 데이터 요청 처리까지 수행
    - 서버는 주로 DBMS(DataBase Management System) 역할만 수행
    - 구형 데스크탑 애플리케이션 (ex. 엑셀 + Access 연동)
    - 클라이언트에서 많은 로직 수행 가능 → 빠른 응답
    - 유지보수 어려움, 클라이언트 사양 높아야 함

- 씬 클라이언트 (Thin Client)
    - 클라이언트는 UI 렌더링 및 사용자 입력만 처리
    - 서버가 비즈니스 로직 + 데이터 처리 전부 담당
    - 웹 브라우저 기반 애플리케이션 (HTML/CSS/JS 프론트)
    - 클라이언트 부담 적고 유지보수 용이
    - 서버에 부하 집중, 네트워크 의존성 높음

### 3. 3계층 클라이언트/서버 구조 (Three-Tier Architecture)
- 프리젠테이션(UI) - 애플리케이션 로직 - 데이터를 각기 다른 계층에 분리하여 설계
    - 클라이언트 계층 (Presentation Tier)
        - 사용자 인터페이스, 사용자 입력 처리 (웹 브라우저, 앱 UI 등)
    - 애플리케이션 계층 (Application/Logic Tier)
        - 비즈니스 로직, 보안 처리, 검증, 트랜잭션 관리
        - 일반적으로 웹서버(Spring, Express 등) 또는 애플리케이션 서버(JBoss, WebLogic)
    - 데이터 계층 (Data Tier)
        - 데이터베이스 관리, 데이터 저장 및 검색
        - RDBMS(MySQL, Oracle), NoSQL 등

### 4. 클라이언트/서버 구조와 미들웨어 (Middleware)
- **미들웨어(Middleware)**는 클라이언트와 서버 간 통신, 데이터 교환, 세션 유지, 로드밸런싱 등을 중재하고 지원하는 소프트웨어 계층
- 역할
    - 통신 관리: TCP/IP, 메시지 큐, RPC, RMI, SOAP, REST API 등
    - 세션 및 트랜잭션 관리: 클러스터 환경에서도 상태 유지
    - 보안 처리: 인증, 인가, 암호화
    - 서비스 디스커버리 및 로드밸런싱: 마이크로서비스 환경에서 중요
- 예시
    - WebSphere, JBoss, Tomcat (애플리케이션 서버)
    - Kafka, RabbitMQ (메시지 큐 기반)
    - gRPC, REST API, Spring Cloud Gateway, Zuul

## 3. 다중 처리 운영체제
### 1. 다중 처리 시스템
- Multiprocessing OS는 다수의 프로세서(CPU)를 관리하고, 이를 통해 병렬로 태스크(프로세스 또는 스레드)를 수행함.
- 단일 CPU 시스템과 달리 여러 CPU가 독립적으로 작업을 실행할 수 있어 처리량(Throughput)이 증가함.
- 특징
    - 병렬성(Parallelism): 여러 작업을 동시에 수행 → 응답시간 및 처리속도 향상
    - 부하분산(Load Balancing): 작업을 여러 CPU에 균등하게 분산 가능
    - 신뢰성 향상(Fault Tolerance): 하나의 CPU가 고장나도 다른 CPU가 작업을 이어받을 수 있음
    - 자원 공유(Resource Sharing): 모든 CPU가 공통 메모리와 디바이스를 공유하는 경우가 많음
- 종류

| 구조 유형          | 특징| 장점                 | 단점| 예시               |
| -------------- | ------------ | ------------------ | ------ | ---------------- |
| 공동 버스 시스템  | 모든 CPU와 메모리가 하나의 버스를 공유              | 구조 단순, 구현 쉬움       | 버스 병목, 확장성 낮음     | 초기 SMP 시스템       |
| 크로스바 교환 행렬 | 각 CPU-메모리 쌍을 스위치 행렬로 직접 연결           | 병목 없음, 동시 접근 가능    | 스위치 수 많음 → 고비용    | 슈퍼컴퓨터, 고급 서버     |
| 다중 포트 메모  | 메모리에 여러 포트 존재 → 여러 CPU가 동시에 접근 가능    | 충돌 줄고 병목 감소        | 하드웨어 복잡, 포트 수 제한  | 중간급 성능 시스템       |
| 하이퍼큐브 시스템  | CPU 노드를 n차 하이퍼큐브 구조로 연결, 각 노드는 n개 연결 | 높은 확장성, 메시지 전달 효율적 | 구조 복잡, 연결 알고리즘 필요 | 병렬 클러스터, 고성능 컴퓨팅 |


### 2. 다중 처리시스템의 운영체제
| 운영체제 유형      | 특징| 확장성    | 신뢰성 | 자원 공유  | 사용 예시                      |
| ------------ | ------------- | ------ | --- | ------ | -------------------------- |
| 주종 운영체제      | 마스터 CPU가 제어, 슬레이브는 명령만 수행    | 낮음     | 낮음  | 제한적    | 초기 임베디드, 제어 시스템            |
| 분리 실행        | 각 CPU가 독립된 OS 실행, 통신은 메시지 기반 | 높음     | 중간  | 없음     | 분산 시스템, loosely-coupled 환경 |
| 대칭(SMP) 운영체제 | 모든 CPU가 하나의 OS 공유, 작업 균등 처리  | 중간\~높음 | 높음  | 공유 메모리 | 현대 멀티코어 시스템, 서버            |

### 3. 클러스터
| 클러스터 유형| 목적 및 특징| 장점                  | 단점| 사용 예시              |
| ------------------ | ---------- | -------- | -------------- | ------------------ |
| 클러스터 구조 (기본형)  | 여러 노드를 네트워크로 연결해 하나의 시스템처럼 동작       | 확장 용이, 비용 대비 성능 우수  | 구성 및 관리 복잡            | 일반 서버 클러스터         |
| 고성능 클러스터 (HPC) | 병렬 계산에 특화된 클러스터, CPU·GPU 연산 집중      | 대규모 계산 가능, 처리 속도 높음 | 고속 네트워크, 병렬 처리 설계 필요  | 과학연산, AI 학습, 시뮬레이션 |
| 부하분산 클러스터      | 요청을 여러 노드에 분산 처리해 응답 속도 향상          | 트래픽 증가 대응, 확장성 우수   | 상태 공유 어려움, 동기화 이슈     | 웹 서버, API 서버 등     |
| 고가용성 클러스터 (HA) | 노드 장애 시 다른 노드가 서비스 자동 인계 (Failover) | 다운타임 최소화, 연속성 보장    | 구성 복잡, 장애 감지/전환 설계 필요 | 금융, 병원, 공공서비스 시스템  |

### 4. 다중처리시스템과 클러스터
| 항목     | 다중처리 시스템 (SMP)  | 클러스터 시스템 (Cluster)  |
| ------ | --------------- | ------------------- |
| CPU 구성 | 하나의 시스템에 다수 CPU | 여러 시스템(CPU) 네트워크 연결 |
| OS     | 하나의 OS 인스턴스     | 각 노드에 독립된 OS        |
| 통신 방식  | 공유 메모리          | 메시지 패싱(네트워크)        |
| 확장성    | 낮거나 제한적         | 상대적으로 높음            |
| 주요 목적  | 빠른 병렬 처리        | 고가용성, 부하분산, 확장성     |




